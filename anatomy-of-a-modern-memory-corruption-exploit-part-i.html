<!DOCTYPE html>
<html lang="en">
<head>

        <meta name="google-site-verification" content="pGw_A7NkX3r_PZULCdMzWHWiOWWIqLUk2Ckj0VjIJ1I" />
        <meta charset="utf-8" />
        <title>Anatomy of a Modern Memory Corruption Exploit - Part I</title>
        <link rel="stylesheet" href="https://wiemerc.github.io/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://wiemerc.github.io/">Constantin Wiemer's Blog  <strong><p>A blog about my programming projects, computer security and systems programming</strong></a></h1>
                <nav><ul>
    
                        <li><a href="https://wiemerc.github.io/pages/about-me.html">About me</a></li>
                    <li><a href="https://wiemerc.github.io/category/computer-history.html">Computer History</a></li>
                    <li class="active"><a href="https://wiemerc.github.io/category/computer-security.html">Computer Security</a></li>
                    <li><a href="https://wiemerc.github.io/category/programming-projects.html">Programming Projects</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-i.html" rel="bookmark"
           title="Permalink to Anatomy of a Modern Memory Corruption Exploit - Part I">Anatomy of a Modern Memory Corruption Exploit - Part I</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>Mon 27 March 2023</span>

</footer><!-- /.post-info -->      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is part one of a series of articles. <a href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-ii.html">Here</a> is part two.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I think my interest in computer security was initially sparked in the 1990s by movies like <em>Sneakers</em> and <em>The Net</em> and then by the book <em>Practical Unix and Internet Security</em>. Since then I have dabbled in it every once in a while, although it never was and still isn&#8217;t a major part of my day job. A couple of years ago I wanted to take a deeper dive and so I played around with reverse engineering, stack overflows and shell code a bit. But as operating systems and applications keep employing ever more sophisticated techniques to keep hackers out, today&#8217;s vulnerabilities and exploits are a lot more complex than simple stack overflows. So I developed the wish to really understand a modern exploit for a somewhat realistic vulnerability. This series of articles will describe what I came up with. If you&#8217;re now wondering what you are to expect, I&#8217;m talking about an exploit for a use-after-free bug that uses a heap spray and ROP to overwrite the vtable of an object and inject the malicious code&#8230;&#8203; But don&#8217;t be afraid if you have no idea what these terms mean, I will explain them step by step. However, you should have some knowledge about C++ (or at least C), assembly and simple exploits like stack overflows. My hope is to bridge the gap between basic articles like the 1996 classic <a href="http://phrack.org/archives/issues/49/14.txt"><em>Smashing the Stack for Fun and Profit</em></a> and very advanced stuff like what is being published by Google&#8217;s <a href="https://googleprojectzero.blogspot.com/">Project Zero</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_victim_program_and_its_vulnerability">The victim program and its vulnerability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For this series of articles I will use a vulnerability in a "victim" program that I specifically wrote for this purpose. This program (<a href="https://github.com/wiemerc/Exploits/blob/main/uaf-overwrite-vtable.cpp"><code>uaf-overwrite-vtable.cpp</code></a>) is a server written in C++ that receives data over HTTP and stores it for further processing. This data is transferred in blocks or <em>chunks</em> using the <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding"><em>Chunked Transfer Encoding</em></a> mechanism. It is base64-encoded, so it could be binary data, but neither the format nor the content are relevant to the vulnerability or the exploit. In fact, the actual data processing is not even implemented in the program.</p>
</div>
<div class="paragraph">
<p>So how does this program look like? The following listing shows how the chunks are read. As the program is started with <a href="https://copyconstruct.medium.com/socat-29453e9fc8a6"><em>socat</em></a>, it can just communicate via standard input and output with the client.</p>
</div>
<div class="listingblock">
<div class="title">Listing 1. Reading the chunks</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HTTPChunk</span><span class="o">*&gt;</span> <span class="n">chunks</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chunk_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="n">line</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"</span><span class="se">\r</span><span class="s">"</span><span class="p">));</span>
    <span class="n">chunk_num</span><span class="o">++</span><span class="p">;</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoul</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Chunk #%ld has %ld bytes</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">chunk_num</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">chunk_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Final chunk received, terminating</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chunk_size</span> <span class="o">&lt;=</span> <span class="n">MAX_CHUNK_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p_chunk</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HTTPChunk</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">);</span>  <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="n">chunks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p_chunk</span><span class="p">);</span>  <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Chunk object at %p, decoded size = %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p_chunk</span><span class="p">,</span> <span class="n">p_chunk</span><span class="o">-&gt;</span><span class="n">get_decoded_size</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Chunk size %ld exceeds maximum size, aborting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"HTTP/1.1 400 Bad Request</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, an object of the <code>HTTPChunk</code> class is created for each chunk <strong>(1)</strong> and these objects are stored in a vector <strong>(2)</strong>. The memory for these objects is allocated on the heap (via the <code>new</code> operator).</p>
</div>
<div class="paragraph">
<p>Later in the program, we can find this piece of code:</p>
</div>
<div class="listingblock">
<div class="title">Listing 2. Decoding the chunks</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">p_chunk</span> <span class="o">:</span> <span class="n">chunks</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">chunk_num</span><span class="o">++</span><span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p_decoded_chunk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">[</span><span class="n">p_chunk</span><span class="o">-&gt;</span><span class="n">get_decoded_size</span><span class="p">()];</span>
        <span class="n">decoded_chunks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p_decoded_chunk</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Buffer for decoded chunk #%ld at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">chunk_num</span><span class="p">,</span> <span class="n">p_decoded_chunk</span><span class="p">);</span>
        <span class="n">p_chunk</span><span class="o">-&gt;</span><span class="n">get_decoded_content</span><span class="p">(</span><span class="n">p_decoded_chunk</span><span class="p">,</span> <span class="n">p_chunk</span><span class="o">-&gt;</span><span class="n">get_decoded_size</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Exception '%s' occurred while decoding chunk, deleting object</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
        <span class="k">delete</span> <span class="n">p_chunk</span><span class="p">;</span>  <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You will probably notice that it contains a (rather obvious) bug. If an exception occurs while trying to decode a chunk (if the data in this chunk is not properly base64-encoded), the chunk object&#8217;s memory is freed <strong>(3)</strong> but the object is kept in the vector. So if the program later iterates again over all objects in the vector (in this case to free them before exiting), it will also access the objects already freed. This constitutes a so-called <a href="https://cwe.mitre.org/data/definitions/416.html"><em>use-after-free</em></a> bug.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exploiting_the_vulnerability">Exploiting the vulnerability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So how can we exploit this bug, thus turning it into a vulnerability? First off, we can only use it for our purposes if we are able to overwrite the freed memory with data we can control, that we can somehow feed into the program. Then there are two possibilities, depending on what was stored in the memory that was freed. It it was data, that is the values of variables, we can change them and maybe thereby alter the program flow. A classical example would be a variable (or the attribute of an object) that stores the id of the authenticated user. If we replace the id of our user with the id of a user with extended privileges (e. g. <em>root</em> with the id 0 in Unix / Linux), we might be able to do things with the program that contains the bug we wouldn&#8217;t be allowed otherwise (a so-called <a href="https://en.wikipedia.org/wiki/Privilege_escalation"><em>priviledge escalation</em></a>).</p>
</div>
<div class="paragraph">
<p>If the freed memory contained code or a code address, e. g. a function pointer, we can change the program&#8217;s behavior in way more far-reaching ways. If we&#8217;re able to change either the code directly or the code address so that it points to code we injected into the program, we can make the program do pretty much anything we want it to do. And exactly this case we have on our hands here, namely a function pointer, or to be more precise a pointer to a method.</p>
</div>
<div class="paragraph">
<p>You might wonder now where in our victim program a method pointer could be. To answer that question, we need to take a closer look at the <code>HTTPChunk</code> class.</p>
</div>
<div class="listingblock">
<div class="title">Listing 3. Declaration of the <code>HTTPChunk</code> class</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">class</span> <span class="nc">HTTPChunk</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mp_buffer</span><span class="p">;</span>  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kt">size_t</span> <span class="n">m_buffer_size</span><span class="p">;</span>

    <span class="nl">public:</span>
        <span class="n">HTTPChunk</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">input_stream</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">chunk_size</span><span class="p">);</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">HTTPChunk</span><span class="p">();</span>  <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="kt">size_t</span> <span class="n">get_decoded_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">get_decoded_content</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">);</span>  <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It mainly consists of a buffer for the chunk data <strong>(1)</strong>, which gets allocated when the objects of this class are constructed, a destructor <strong>(2)</strong> that frees this buffer and a method <code>get_decoded_content</code> <strong>(3)</strong> that decodes the base64-encoded chunk data and writes it into a caller-supplied buffer. Crucial to the vulnerability and the exploit is the fact that the class has <strong>virtual</strong> methods (<code>get_decoded_content</code> and the destructor). This is because virtual methods cause the compiler to generate for the class a table of these methods, the so-called <a href="https://en.wikipedia.org/wiki/Virtual_method_table"><em>virtual method table</em></a> or <em>vtable</em>. The methods are not invoked directly but indirectly using the pointers to the methods stored in this table. The reasons for this and the details are explained in the linked Wikipedia article. Even more information can be found in <a href="https://shaharmike.com/cpp/vtable-part1/">this</a> and <a href="https://martinkysel.com/demystifying-virtual-tables-in-c-part-3-virtual-tables/">this</a> article.</p>
</div>
<div class="paragraph">
<p>So if we&#8217;re able to change the vtable, we might be able to execute injected code. But before we can change the vtable (or even replace it completely), we need to know first where it&#8217;s located in the program. This shows us the following GDB session (the program was stopped at the line marked with <strong>(2)</strong> in listing 1).</p>
</div>
<div class="listingblock">
<div class="title">Listing 4. Looking at the vtable in the debugger</div>
<div class="content">
<pre>pwndbg&gt; set print asm-demangle on
pwndbg&gt; set print demangle on

pwndbg&gt; p sizeof(HTTPChunk)  <i class="conum" data-value="1"></i><b>(1)</b>
$1 = 12

pwndbg&gt; x/3dx p_chunk  <i class="conum" data-value="2"></i><b>(2)</b>
0x88d9c40:	<strong>0x0804feb8</strong>	0x088d9c50	0x00000001
pwndbg&gt; i sym <strong>0x0804feb8</strong>
vtable for HTTPChunk + 8 in section .data.rel.ro of /home/consti/Programmieren/Exploits/uaf-overwrite-vtable

pwndbg&gt; x/3dx <strong>0x0804feb8</strong>  <i class="conum" data-value="3"></i><b>(3)</b>
0x804feb8 &lt;vtable for HTTPChunk+8&gt;:	0x0804acca	0x0804ad26	0x0804ad7a
pwndbg&gt; i sym 0x0804acca
HTTPChunk::~HTTPChunk() in section .text of /home/consti/Programmieren/Exploits/uaf-overwrite-vtable  <i class="conum" data-value="4"></i><b>(4)</b>
pwndbg&gt; i sym 0x0804ad26
HTTPChunk::~HTTPChunk() in section .text of /home/consti/Programmieren/Exploits/uaf-overwrite-vtable  <i class="conum" data-value="5"></i><b>(5)</b>
pwndbg&gt; i sym 0x0804ad7a
HTTPChunk::get_decoded_content(unsigned char*, unsigned int) in section .text of /home/consti/Programmieren/Exploits/uaf-overwrite-vtable  <i class="conum" data-value="6"></i><b>(6)</b></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see <strong>(1)</strong>, the size of <code>HTTPChunk</code> objects is 12 bytes or 3 double words (if the program was compiled for a 32-bit processor architecture, which is the case with our program). Two of them are of course the object attributes, the pointer to the buffer holding the chunk data and the chunk size, respectively. But what about the third double word? To find out, I dumped an object and checked if any of the double words can be found in the program&#8217;s symbol table <strong>(2)</strong>. And lo and behold, the first one points to the vtable of the <code>HTTPChunk</code> class (actually not to the start of the table but 8 bytes in, but this is not relevant here). Now we know that objects of a class with virtual methods start with a pointer to the vtable (at least if we use GCC, the memory layout of an object depends on the compiler). You can also see that the vtable is stored in a write-protected memory area, namely the <code>.data.rel.ro</code> section of the program.</p>
</div>
<div class="paragraph">
<p>So how does the table itself look like? It again consists of three double words, the pointers to the virtual methods <strong>(3)</strong>. You might now wonder why there are two destructors and you wouldn&#8217;t be alone. <a href="https://stackoverflow.com/questions/44558119/why-do-i-have-two-destructor-implementations-in-my-assembly-output">This</a> answer on Stack Overflow explains why GCC creates two, namely the so-called <em>complete object destructor</em> <strong>(4)</strong> and the <em>deleting destructor</em> <strong>(5)</strong>. The third pointer <strong>(6)</strong> points of course to the <code>get_decoded_content</code> method.</p>
</div>
<div class="paragraph">
<p>This knowledge enables us now to outline a possible exploit for the vulnerability in the victim program.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We inject the code we want to execute into the program.</p>
</li>
<li>
<p>We construct a new vtable where one pointer doesn&#8217;t point to a method of the class but to the injected code instead. This vtable must also be injected into the program.</p>
</li>
<li>
<p>We overwrite the pointer to the vtable of an existing object with a pointer to the vtable constructed in step 2.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Is the method with the overwritten pointer later called on the modified object, our injected code will be executed&#8230;&#8203; bingo :-) The remainder of this article and the other two articles in this series will show you how to perform the exploit in detail.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_step_1_calling_a_pre_defined_routine_in_the_victim">Step 1: Calling a pre-defined routine in the victim</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this first step we will make our lives a little easier. Instead of injecting the malicious code, that is the code we want to execute, we will incorporate it in the victim program as a routine. This is of course (in most cases) not a realistic scenario, but it makes it easier to develop the exploit step by step. So this means we "only" need to replace the pointer to the vtable and the vtable itself.</p>
</div>
<div class="paragraph">
<p>To change the pointer to the vtable of an existing object, we make use of several facts. First, all objects stored in the vector <code>chunks</code> are processed in a loop one after another. Second, the memory of the objects, for which the decoding of the data fails, is freed but the pointer to the object is kept in the vector (see listing 2). Finally, there is a new buffer allocated for the decoded chunk data for each object that is processed in the loop. This means that after freeing one object&#8217;s memory (which contains the pointer to the vtable), new memory is allocated that we can <strong>fill with arbitrary data</strong> (because it&#8217;s the buffer for the next chunk&#8217;s decoded data). We just need to find a way to force the program to <strong>re-use</strong> the object&#8217;s memory for the next allocation, then we&#8217;re able to modify deleted objects arbitrarily. I don&#8217;t want to go into the <a href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">details</a> of how memory allocations work on Linux with the GNU C standard library (the operator <code>new</code> uses the routine <code>malloc</code> under the hood). But an easy way is to make the size of the next chunk&#8217;s decoded data match the size of the <code>HTTPChunk</code> objects (depending on the block size used by <code>malloc</code> and the size of the objects, it might also work if the next chunk is slightly smaller).</p>
</div>
<div class="paragraph">
<p>So what we need for the exploit is two specially constructed chunks that we feed into the program. The first chunk can be any size, but it needs to contains incorrectly encoded data. The size of the decoded second chunk must, as I just explained, equal the size of the <code>HTTPChunk</code> objects (12 bytes) and it must contain a pointer to the new vtable (the other data doesn&#8217;t matter).</p>
</div>
<div class="paragraph">
<p>The new vtable itself will be injected into the program using a third chunk. This vtable consists of three entries, each a pointer to the routine <code>pwned_destructor</code> in the program. This is the routine that contains the "malicious" code we want to execute (it just prints the string "You&#8217;ve been pwned!!!").</p>
</div>
<div class="paragraph">
<p>You might think we&#8217;d be done now and you would have been right 15 or 20 years ago. But nowadays systems usually use <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization"><em>ASLR</em></a> to prevent exactly this kind of attacks. This means that all memory addresses (code and data) are randomized and differ from one invocation of a program to the next. So there is no (easy) way for us to know where the <code>pwned_destructor</code> routine and the buffer for the decoded third chunk (which contains our vtable) are located. I will show you a way to (partially) bypass ASLR in the second article of this series, but for now we will just disable it when we run the victim program (with the <code>setarch</code> command).</p>
</div>
<div class="paragraph">
<p>The following listing shows the (shortened) output of the program when the exploit is run against it (using the script <a href="https://github.com/wiemerc/Exploits/blob/main/exploit-uaf.py"><code>exploit-uaf.py</code></a>).</p>
</div>
<div class="listingblock">
<div class="title">Listing 5. The exploit in action</div>
<div class="content">
<pre>$ setarch $(uname -m) -R socat tcp-l:9999,reuseaddr exec:./uaf-overwrite-vtable
Waiting for requests...
Reading chunks...
Chunk #1 has 1 bytes
Chunk object at <strong>0x8056c40</strong>, decoded size = 0
Chunk #2 has 16 bytes
Chunk object at 0x8056c70, decoded size = <strong>12</strong>  <i class="conum" data-value="1"></i><b>(1)</b>
Chunk #3 has 16 bytes
Chunk object at 0x8056c60, decoded size = 12
Chunk #4 has 0 bytes
Final chunk received, terminating
Processing chunks...
Buffer for decoded chunk #1 at 0x8056ca0
Exception 'Size of base64-encoded data is not a multiple of 4' occurred while decoding chunk, deleting object  <i class="conum" data-value="2"></i><b>(2)</b>
HTTPChunk::~HTTPChunk() called  <i class="conum" data-value="3"></i><b>(3)</b>
Buffer for decoded chunk #2 at <strong>0x8056c40</strong>  <i class="conum" data-value="4"></i><b>(4)</b>
Buffer for decoded chunk #3 at <strong>0xe8ea9010</strong>
You've been pwned!!!  <i class="conum" data-value="5"></i><b>(5)</b>
HTTPChunk::~HTTPChunk() called
HTTPChunk::~HTTPChunk() called</pre>
</div>
</div>
<div class="paragraph">
<p>There are a few things to note here. First, we can see that the size of the decoded second chunk is the same as the size of the <code>HTTPChunk</code> objects <strong>(1)</strong>, which is, as stated before, a prerequisite for the exploit to work. In the line marked with <strong>(2)</strong> we see that an exception occurs when the victim tries to decode the first chunk and the chunk object gets deleted, which is confirmed by the next line <strong>(3)</strong> that tells us that the destructor is called. All the magic happens when the buffer for the second chunk is allocated <strong>(4)</strong> because it gets allocated <strong>at the address where the deleted first chunk object lived</strong> (0x8056c40), thus overwriting the object&#8217;s memory. The line marked with <strong>(5)</strong> shows us that the exploit actually works.</p>
</div>
<div class="paragraph">
<p>We can also take a look at the program with debugger right before the first chunk object is about to be deleted for the second time (before the program exits, at line 174).</p>
</div>
<div class="listingblock">
<div class="title">Listing 6. The deleted chunk object in the debugger</div>
<div class="content">
<pre>pwndbg&gt; x/3dx p_chunk
<strong>0x8056c40</strong>:      <strong>0xe8ea9010</strong>      0x78787878      0x78787878  <i class="conum" data-value="1"></i><b>(1)</b>
pwndbg&gt; x/3dx 0xe8ea9010
0xe8ea9010:     0x0804a3dd      0x0804a3dd      0x0804a3dd  <i class="conum" data-value="2"></i><b>(2)</b>
pwndbg&gt; i sym 0x0804a3dd  <i class="conum" data-value="3"></i><b>(3)</b>
pwned_destructor() in section .text of /home/consti/Programmieren/Exploits/uaf-overwrite-vtable</pre>
</div>
</div>
<div class="paragraph">
<p>This confirms that the object&#8217;s memory has been overwritten with a pointer to our fake vtable <strong>(1)</strong>, which is a pointer to the buffer for the decoded third chunk (0xe8ea9010), and that the vtable consists of pointers to <code>pwned_destructor</code> (<strong>(2)</strong> and <strong>(3)</strong>).</p>
</div>
<div class="paragraph">
<p>With that we have reached the end of part one of this series. In part two we will make the exploit more realistic by defeating ASLR and actually injecting the malicious code. Stay tuned if you liked it so far&#8230;&#8203;</p>
</div>
</div>
</div>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
            <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>. Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, inspired by the default theme.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>