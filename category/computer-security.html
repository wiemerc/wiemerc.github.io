<!DOCTYPE html>
<html lang="en">
<head>

        <meta name="google-site-verification" content="pGw_A7NkX3r_PZULCdMzWHWiOWWIqLUk2Ckj0VjIJ1I" />
        <meta charset="utf-8" />
        <title>Constantin Wiemer's Blog - Computer Security</title>
        <link rel="stylesheet" href="https://wiemerc.github.io/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://wiemerc.github.io/">Constantin Wiemer's Blog  <strong><p>A blog about my programming projects, computer security and systems programming</strong></a></h1>
                <nav><ul>
    
                        <li><a href="https://wiemerc.github.io/pages/about-me.html">About me</a></li>
                    <li><a href="https://wiemerc.github.io/category/computer-history.html">Computer History</a></li>
                    <li class="active"><a href="https://wiemerc.github.io/category/computer-security.html">Computer Security</a></li>
                    <li><a href="https://wiemerc.github.io/category/programming-projects.html">Programming Projects</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-ii.html">Anatomy of a Modern Memory Corruption Exploit - Part II</a></h1>
<footer class="post-info">
        <span>Sun 09 April 2023</span>

</footer><!-- /.post-info --><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is part two of a series of articles. <a href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-i.html">Here</a> is part one.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_step_2_calling_a_pre_defined_routine_in_the_victim_with_aslr_enabled">Step 2: Calling a pre-defined routine in the victim with ASLR enabled</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In step 1 in the <a href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-i.html">first</a> article of this series we had disabled ASLR in order to have the buffer for the decoded third chunk at a fixed address. Now we will raise the bar for the exploit by enabling ASLR for data, that is for memory on the stack and heap. We will keep ASLR disabled for code (by preventing GCC from creating a <a href="https://en.wikipedia.org/wiki/Position-independent_code">position-independent executable (PIE)</a> with the <code>-Wl,-no-pie</code> compiler flag), so our routine <code>pwned_destructor</code> still lives at a fixed address.</p>
</div>
<div class="paragraph">
<p>So how can we defeat ASLR? We somehow need to find out the address of the third chunk&#8217;s buffer (because it contains the fake vtable), despite it being a random value now that differs from one invocation of the victim program to the other. We are helped here by the fact that we have a 32-bit program on our hands. As it turns out, with the somewhat limited address space of 32-bit programs (4GB), there are not that many addresses for the kernel to choose from, especially for large memory blocks. The plot below shows the address ranges (start and end addresses of the memory blocks) for different block sizes as obtained by repeated invocations of a program that just calls <code>malloc</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://wiemerc.github.io/images/uaf/malloc-address-ranges.svg" alt="malloc address ranges">
</div>
<div class="title">Figure 1. Address ranges returned by <code>malloc</code> by allocation size (with 14 random bits for <code>mmap</code>)</div>
</div>
<div class="paragraph">
<p>As you can see, if we allocate large enough blocks (100MB in the figure), <strong>all</strong> address ranges overlap to some extent. This means there is an address range <strong>that is guaranteed to be included</strong> in each and every memory block we allocate. The actual size threshold above which this is the case depends on a kernel parameter (<code>/proc/sys/vm/mmap_rnd_compat_bits</code>), which tells the kernel how many random bits it should use for the <code>mmap</code> system call (<code>mmap</code> is used internally by <code>malloc</code> for large allocations). The default seems to be 8 bits (see <a href="https://lwn.net/Articles/667790/">this</a> article for more details), with this value a memory block of a size of 100MB <strong>always</strong> gets allocated at the same address. To make things more interesting, I cranked up the value to 14 bits. With that value you get the behavior shown in the figure.</p>
</div>
<div class="paragraph">
<p>So how does this knowledge help us with the exploit? We would need a large memory allocation (e. g. 100MB) to happen in the program and our fake vtable to be located at an address that is always included in the allocated memory block. This is actually quite easy to accomplish. In the previous step we put just one copy of the vtable in the third chunk. But we can make the third chunk much larger and put <strong>lots of copies</strong> of the vtable in it. Then we no longer use the start address (which changes) of the buffer for the chunk&#8217;s data but an address somewhere in the middle (which stays the same) of this buffer as pointer to the vtable, or to be more precise, to <strong>one copy</strong> of it. Because the buffer is located on the heap and we sort of "spray" data onto it, this technique is called <a href="https://en.wikipedia.org/wiki/Heap_spraying">heap spraying</a>. However, it is, as described here, only possible with 32-bit programs. Due to their <strong>much</strong> larger address spaces (256 TB), with 64-bit programs it&#8217;s in general not possible to allocate memory blocks large enough to get overlapping address ranges. For them, this technique must be combined with a way to find out the program&#8217;s address space layout (at least partially), but this is beyond the scope of this series of articles. If I made you curious now, you can read more about this <a href="https://googleprojectzero.blogspot.com/2015/06/dude-wheres-my-heap.html">here</a> for example.</p>
</div>
<div class="paragraph">
<p>How a heap spray looks like in reality is shown in the debugger session below. We take a closer look at the first <code>HTTPChunk</code> object (which got overwritten) right before it&#8217;s about to be deleted.</p>
</div>
<div class="listingblock">
<div class="title">Listing 1. Demo of the heap spraying</div>
<div class="content">
<pre>Breakpoint 1, main () at ./uaf-overwrite-vtable.cpp:179
177             delete p_chunk;

pwndbg&gt; x/3dx p_chunk
0x98a3c40:      0xe9000000      0x78787878      0x78787878  <i class="conum" data-value="1"></i><b>(1)</b>
pwndbg&gt; x/16dx 0xe9000000
0xe66a9010:     0x0804a3dd      0x0804a3dd      0x0804a3dd      0x0804a3dd  <i class="conum" data-value="2"></i><b>(2)</b>
0xe66a9020:     0x0804a3dd      0x0804a3dd      0x0804a3dd      0x0804a3dd
0xe66a9020:     0x0804a3dd      0x0804a3dd      0x0804a3dd      0x0804a3dd
0xe66a9020:     0x0804a3dd      0x0804a3dd      0x0804a3dd      0x0804a3dd
pwndbg&gt; i sym 0x0804a3dd  <i class="conum" data-value="3"></i><b>(3)</b>
pwned_destructor() in section .text of /home/consti/Programmieren/Exploits/uaf-overwrite-vtable</pre>
</div>
</div>
<div class="paragraph">
<p>We can see <strong>(1)</strong> that the object&#8217;s pointer to its vtable now points to the address 0xe9000000. If we inspect the memory at this address we see <strong>(2)</strong> that it indeed contains pointers to the <code>pwned_destructor</code> routine <strong>(3)</strong>, which make up the vtable. So where does this magic value 0xe9000000 come from? I found it by running the program a few times and choosing a value that was always included in the buffer for the third chunk (somewhere in the middle of it). It only needs to be aligned on a double-word address, then it&#8217;s bound to hit a vtable.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_step_3_injecting_the_malicious_code_into_the_victim">Step 3: Injecting the malicious code into the victim</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So far, we haven&#8217;t injected any code (that we would control) into the program but used a routine already contained in the program. As I have mentioned, this is normally not a realistic scenario. So we will now ditch the routine and see how we can inject our own code.</p>
</div>
<div class="paragraph">
<p>First off, the injected code must of course be self-contained and position-independent, that is it must be able to run from any location in memory and must not rely on anything other than system calls. This type of code is usually known as <a href="https://en.wikipedia.org/wiki/Shellcode"><em>shellcode</em></a>. The shellcode we will use looks like this:</p>
</div>
<div class="listingblock">
<div class="title">Listing 2. Our shellcode</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="gas">.code32
jmp     l_data
l_code:
mov     ebx, 2      # file descriptor, 2 = stderr
pop     ecx         # pointer to buffer
mov     edx, 30     # buffer size
mov     eax, 4      # system call number, 4 = write
int     0x80        # invoke system call
ret

l_data:
call    l_code      # call to push the string's address onto the stack
.asciz  "\x1b[31mYou've been pwned!!!\x1b[0m\n"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The term shellcode is actually a bit misleading here as we don&#8217;t start a shell but just print a string. As you can see, the code is quite simple. First, it performs the <a href="https://marcosvalle.github.io/osce/2018/05/06/JMP-CALL-POP-technique.html"><em>JMP-CALL-POP</em></a> trick to get the address of the string we want to print on the stack, then it invokes the <code>write</code> system call and returns (because it will be called as a method via the vtable). I translated the code into a raw binary (just the code, no headers and other stuff) using GNU <code>as</code> and <code>objdump</code> so that the Python <a href="https://github.com/wiemerc/Exploits/blob/main/exploit-uaf.py">script</a> that performs the exploit can use it.</p>
</div>
<div class="paragraph">
<p>So how are we going to deliver this code to the victim program? We will use another chunk for that. But we need to find again a way to use a fixed start address (that we will put into the vtable), despite the start address of the chunk&#8217;s buffer being random. As you might have guessed, the heap spraying, described in the previous step, comes to the rescue once more. But instead of putting lots of copies of our code into the chunk (as we did with the vtable), we will use a technique known as <a href="https://en.wikipedia.org/wiki/NOP_slide"><em>NOP slide</em></a> (or <em>NOP sled</em>). You might be familiar with this technique if you know a bit about classical stack overflows. What it means is that we will create a large chunk (again 100MB), fill it almost completely with NOP instructions and put our shellcode at the very end of it. Then we will use an address that is guaranteed to be included in the chunk&#8217;s buffer as pointer to our code and put that address in our fake vtable. This address will definitely point to a NOP and when the CPU finally jumps to it, program execution will "slide" down the NOPs until it reaches the shellcode. Note that we don&#8217;t care about null bytes in the shellcode as we don&#8217;t deliver it as string but as base64-encoded data.</p>
</div>
<div class="paragraph">
<p>In the following debugger session we will take a closer look at this fourth chunk containing the code.</p>
</div>
<div class="listingblock">
<div class="title">Listing 3. Demo of the code injection</div>
<div class="content">
<pre>Breakpoint 1, main () at ./uaf-overwrite-vtable.cpp:179
177             delete p_chunk;

pwndbg&gt; x/3dx p_chunk
0x8effc40:      0xe2000000      0x78787878      0x78787878  <i class="conum" data-value="1"></i><b>(1)</b>
pwndbg&gt; x/8dx 0xe2000000
0xe2000000:     0xdbc00000      0xdbc00000      0xdbc00000      0xdbc00000  <i class="conum" data-value="2"></i><b>(2)</b>
0xe2000010:     0xdbc00000      0xdbc00000      0xdbc00000      0xdbc00000
pwndbg&gt; x/8bx 0xdbc00000
0xdbc00000:     0x90    0x90    0x90    0x90    0x90    0x90    0x90    0x90
pwndbg&gt; x/8i 0xdbc00000
   0xdbc00000:  nop  <i class="conum" data-value="3"></i><b>(3)</b>
   0xdbc00001:  nop
   0xdbc00002:  nop
   0xdbc00003:  nop
   0xdbc00004:  nop
   0xdbc00005:  nop
   0xdbc00006:  nop
   0xdbc00007:  nop
pwndbg&gt; x/12i (0xd9b52010 + 0x6400000 - 60)
   0xdff51fd4:  nop
   0xdff51fd5:  nop
   0xdff51fd6:  nop
   0xdff51fd7:  jmp    0xdff51fec  <i class="conum" data-value="4"></i><b>(4)</b>
   0xdff51fd9:  mov    ebx,0x1
   0xdff51fde:  pop    ecx
   0xdff51fdf:  mov    edx,0x1e
   0xdff51fe4:  mov    eax,0x4
   0xdff51fe9:  int    0x80
   0xdff51feb:  ret
   0xdff51fec:  call   0xdff51fd9
   0xdff51ff1:  sbb    ebx,DWORD PTR [ebx+0x33]
pwndbg&gt; x/1s 0xdff51ff1
0xdff51ff1:     "\033[31mYou've been pwned!!!\033[0m\n"  <i class="conum" data-value="5"></i><b>(5)</b></pre>
</div>
</div>
<div class="paragraph">
<p>But before we do that we note that our overwritten object still contains a pointer to the chunk containing our fake vtables <strong>(1)</strong>, although with a different value than before (0xe2000000 instead of 0xe9000000). And of course the vtable looks different now as well. It contains pointers with the value 0xdbc00000 <strong>(2)</strong>. So what is there at this address? If we display the memory as instruction <strong>(3)</strong> we see lots of NOPs. So it seems the address is somewhere located in the buffer for the decoded fourth chunk, in the NOP slide. If we examine the end of this buffer (0xd9b52010 is the start address of the buffer, conveniently printed out by the program) we find our shellcode <strong>(4)</strong> together with the string it prints <strong>(5)</strong>.</p>
</div>
<div class="paragraph">
<p>I arrived at these two addresses (0xe2000000 and 0xdbc00000) again by running the program a few times and choosing values that were always included in the respective buffers. Interestingly, the buffer for the fourth chunk was always located 100MB below the buffer for the third chunk. The following diagram shows the locations of the chunk&#8217;s buffers in memory and their relation (what points to what).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://wiemerc.github.io/images/uaf/chunk-buffers.svg" alt="chunk buffers">
</div>
<div class="title">Figure 2. Location of the chunk buffers in memory and their relation</div>
</div>
<div class="paragraph">
<p>So when the destructor is finally called on the overwritten object, via the pointer in the vtable, the CPU will jump right into the NOP slide, execute all the NOPs until it reaches the shellcode and then the shellcode itself.</p>
</div>
<div class="paragraph">
<p>Except&#8230;&#8203; it doesn&#8217;t, not yet at least. Instead, the program terminates with a segmentation fault. Why is that? Another security measure employed by modern CPUs and operating systems keeps us from succeeding. It is commonly known as <a href="https://en.wikipedia.org/wiki/Executable_space_protection#Windows"><em>data execution prevention (DEP)</em></a> or <a href="https://en.wikipedia.org/wiki/W%5EX"><em>W^X</em></a> and means that any memory regions that are writeable by a program (on the heap or stack) are by default not executable (implemented via the <a href="https://en.wikipedia.org/wiki/NX_bit"><em>NX bit</em></a>). As the chunk&#8217;s buffer is of course writeable, the CPU will not execute the code in it but generate an exception which leads in turn to the segmentation fault.</p>
</div>
<div class="paragraph">
<p>So how can we get around this security measure? In the third part of this series I will show you a very clever technique that works by not injecting code into the program but something else. But for now, we will just play a bit unfair and change the permissions of the chunk&#8217;s buffer. This can be done very easily in the debugger as you can see below.</p>
</div>
<div class="listingblock">
<div class="title">Listing 4. Changing the permissions of the chunk&#8217;s buffer</div>
<div class="content">
<pre>pwndbg&gt; vmmap 0xd9b52010  <i class="conum" data-value="1"></i><b>(1)</b>
     Start        End Perm     Size Offset File
0xd9b52000 0xf6e00000 rw-p 1d2ae000      0 [anon_d9b52] +0x0
pwndbg&gt; call (long) mprotect(0xd9b52000, 0x1d2ae000, 0x7)  <i class="conum" data-value="2"></i><b>(2)</b>
$4 = 0</pre>
</div>
</div>
<div class="paragraph">
<p>First I use the <code>vmmap</code> command (provided by the <a href="https://github.com/pwndbg/pwndbg"><em>pwndbg</em></a> extension) to check the permissions of the buffer <strong>(1)</strong> and you can see that it&#8217;s indeed not executable (it misses the "x" bit). Then I call the <code>mprotect</code> system call <strong>(2)</strong> to change the permissions (I don&#8217;t use the start address and size of the buffer but of the complete memory mapping, 0x7 means "rwx"). After that the exploit actually works.</p>
</div>
<div class="paragraph">
<p>This is the end of the second article in this series. As I already said we will defeat W^X in the third article. Stay tuned if you liked it so far&#8230;&#8203;</p>
</div>
</div>
</div>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-i.html" rel="bookmark"
                           title="Permalink to Anatomy of a Modern Memory Corruption Exploit - Part I">Anatomy of a Modern Memory Corruption Exploit - Part I</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <span>Mon 27 March 2023</span>

</footer><!-- /.post-info -->                <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is part one of a series of articles. <a href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-ii.html">Here</a> is part two.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I think my interest in computer security was initially sparked in the 1990s by movies like <em>Sneakers</em> and <em>The Net</em> and then by the book <em>Practical Unix and Internet Security</em>. Since then I have dabbled in â€¦</p></div></div></div>
                <a class="readmore" href="https://wiemerc.github.io/anatomy-of-a-modern-memory-corruption-exploit-part-i.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
            </ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 1
</p>
            </section><!-- /#content -->
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
            <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>. Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, inspired by the default theme.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>